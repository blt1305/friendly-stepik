import re

number = '2.13.3'
# Цвета в формате HEX - способ представления rgb-цветов в шестнадцатеричной системе счисления.
# Они состоят из 6 шестнадцатиричных чисел, каждая пара отвечает за свой цвет:
#
#     Две первые цифры — красный
#     Две в середине — зелёный
#     Две последние цифры — синий
#
# Напишите регулярное выражение, которое будет находить валидные hex-цвета.
# Что нужно найти:
#
# Нужно найти последовательности, подходящие по следующим условиям:
#
#     В начале стоит #
#     Потом идёт последовательность из 6 шестнадцатеричных цифр верхнего и нижнего регистров: 0123456789abcdefABCDEF
#     Последовательность не может быть подпоследовательностью
s = '0.3 1.32 1 -6 1 6 0.77 1 2 0.4 0 0.356 0.32 0.7'
print(number, s)
r = r'\b(?:0|1)\.{0,1}[1-9]{0,2}\b'
print(' ' * len(number), re.findall(r, s))
print()

number = '2.13.6'
#Напишите регулярное выражение, которое найдёт слова, после которых следующим символом идёт один из следующих знаков
# препинания: .,:?!;
s = 'Эй, Богдан, я здесь Эх, Богдан, Богдан, Богом дан Богдан, Богом дан, е Я Богдан, я Богом дан, меня Бог дал Я Богдан, ' \
    'я Богом дан'
print(number, s)
r = r'[а-яА-ЯёЁ]{1,}(?=[/./,/:/?/!/;])'
print(' ' * len(number), re.findall(r, s))
print()

number = '2.13.13'
#Найдите в тексте все названия файлов и их расширения.
#
# Нужно найти последовательности, подходящие по следующим условиям:
#
#     Название файла состоит из: букв латинского алфавита верхнего и нижнего регистров, цифр, -
#     Между названием и расширением файла стоит .
#     Расширение файла состоит из букв латинского алфавита верхнего и нижнего регистров, цифр
#     Минимальная длина названия и расширения - один символ
#     Найденная последовательность может являться подпоследовательностью, только если стоит в абсолютном или относительном пути:
#     C:\Users\test.txt, ../Users/test.txt, т.е. перед ней стоят символы / или \

s = 'Untitled-1.psd Untitled-1.jpg video.mp4'
print(number, s)
r = r'(?<=\\|\/)[a-zA-Z0-9\-]{1,}\.[a-zA-Z0-9]{1,}'
print(' ' * len(number), re.findall(r, s))
print()

number = '2.13.14'
#Получите все идентификаторы видеороликов на YouTube, используя регулярные выражения.
# Нужно найти последовательности, подходящие по следующим условиям:
#
#     Cостоит из символов латинского алфавита обоих регистров, цифр, а также _
#     Перед последовательностью стоит v=
s = 'https://youtu.be/watch?v=dQw4w9WgXcQ&list=PLi9drqWffJ9FWBo7ZVOiaVy0UQQEm4IbP'
print(number, s)
r = r'(?<=v\=)[a-zA-Z0-9_]{1,}'
print(' ' * len(number), re.findall(r, s))
print()

#2.13.15
# Найдите все валидные пустые массивы, или массивы с числами. Числом считаем произвольную последовательность из цифр.
# Что нужно найти:
#
# Нужно найти последовательности, подходящие по следующим условиям:
#
#     Начинается с [ и заканчиваются на ]
#     Внутри может быть пусто, а могут находиться числа
#     Числом считаем произвольную последовательность из цифр
#     Между числами должны стоять запятые
#     Запятые могут быть как и с пробелом, так и без
#     После последнего числа может стоять запятая, т.к. такие массивы: [123, 123, ] и [23, ] валидные в Python

#s = '[1, 23, 3, 436, 5, 63673, 47][2][][4, 05][1, 2, 3, 4, 5, 6, 7424234234234243242, 5][6246546456][432][0][3240, 00] [402030, 404040]'
#print(s)
#r = r'\[(\d)*(,)?((\s)?(\d)*(,)?)+\]'


#print(re.findall(r, s))